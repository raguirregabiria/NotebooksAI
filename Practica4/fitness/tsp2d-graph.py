#!/usr/bin/python
# -*- coding: iso-8859-1 -*-

import matplotlib.pyplot as plt

# Generate N cities

import random
N = 100

cities = []

for i in range(N):
	c = [random.random(), random.random()]
	cities.append(c)

print(cities)

cities = [[0.8744058793117488, 0.30207179832703746], [0.6901572276474558, 0.8203362566663311], [0.7793458478083026, 0.09728979746351918], [0.7483358474304422, 0.4563419482458657], [0.4556164527790729, 0.12863149772605698], [0.1837236688553453, 0.23773749495644914], [0.806151832654163, 0.3288366900529254], [0.6222702185205219, 0.6019431085670109], [0.21886861543988367, 0.6980104036528004], [0.9706096813038716, 0.054871876245520146], [0.13881496219356027, 0.048489530185603646], [0.08511086492841424, 0.9123075505436051], [0.45436952164297595, 0.4731540740573398], [0.8986352255038935, 0.5116579750591849], [0.9539248970461742, 0.7530784036308166], [0.6321102985156373, 0.13575967095580344], [0.31130918313591205, 0.8545457319320597], [0.025897479791937017, 0.7854526665590987], [0.31414095045738066, 0.051421702103483846], [0.2739561013272712, 0.1970964027924862], [0.22762328443470214, 0.627414210742153], [0.44920042912037383, 0.18835427573438068], [0.2793138301174244, 0.9103956650199608], [0.005128451667189338, 0.4655718085045638], [0.9222718335261915, 0.8613103704784812], [0.49352498279326595, 0.28652416807644077], [0.5560886356057152, 0.034564925228364185], [0.0048939219846825255, 0.8635350555457212], [0.7824462381771976, 0.09355415747424733], [0.2973635133076785, 0.037580527218207815], [0.659068210692151, 0.5602321147981546], [0.43549418718677035, 0.6241289474799954], [0.25580657871099755, 0.519726015381631], [0.5950780852425872, 0.3193476592023645], [0.15763623266223903, 0.18210618406479095], [0.3434173147566393, 0.32992255868483356], [0.06451313705472006, 0.12606114349173192], [0.23212286400737547, 0.3945559700824013], [0.955507285594692, 0.02296933408938162], [0.7459955912073274, 0.1385374827130177], [0.46365765315595475, 0.6132297411379687], [0.20196772698059162, 0.046358747430397584], [0.2980093518214506, 0.36041197123227897], [0.7533459401199348, 0.6610562232191091], [0.323433933838161, 0.5068337090138902], [0.062138830138457, 0.7177455044259695], [0.47467832142010535, 0.17692718986260936], [0.2415634321550142, 0.500852093941769], [0.3441878827094532, 0.2604351258948506], [0.5445252142594251, 0.7295590645635646], [0.25391391610860914, 0.7641244059389684], [0.2630560480211699, 0.010670642241309536], [0.2092202940037915, 0.7415775443241935], [0.0031474687633804566, 0.6974574785842637], [0.4952329615559806, 0.9311775894780175], [0.1978488658972426, 0.8872693649066419], [0.1705364411799497, 0.8846808176103278], [0.7634962513234275, 0.4358457309207533], [0.9259752834140167, 0.0056226911773098465], [0.22090405091557253, 0.14500040130773872], [0.4636205151855679, 0.19249574424477278], [0.8057632881682811, 0.250168118157608], [0.6785236695642043, 0.39119477830554505], [0.4837264739606879, 0.23045417711558214], [0.8786721718893166, 0.015853186240832207], [0.1263309724872509, 0.9185321014517236], [0.24969404380600335, 0.9600467657522086], [0.5886119367943214, 0.10948123668473264], [0.13373527735293878, 0.5336853876899833], [0.5642696742735989, 0.9801384844337597], [0.646401605512568, 0.3338636388089157], [0.05603526365085032, 0.3149530712641142], [0.387141492676661, 0.5792852545912592], [0.8634070619751958, 0.8206820685065667], [0.4662474858565825, 0.32647667516764145], [0.01801973379815025, 0.12175434785651695], [0.6218125565554127, 0.07860046445444713], [0.6573938922925594, 0.5023092428939168], [0.2837581848186974, 0.02576704782244421], [0.3044774374252185, 0.7310313422019327], [0.33131673439274434, 0.693896434962478], [0.8523694048117944, 0.2805224723356823], [0.6200019812032047, 0.03989814578273998], [0.5437394088109648, 0.3258031129949792], [0.4386079860370994, 0.6142798815693052], [0.7430581106897977, 0.49260737229959284], [0.3913628378102181, 0.3185830750836698], [0.9065498976196814, 0.02381958527497441], [0.6874236611131453, 0.18642068590773597], [0.6946411585627993, 0.36991609629423117], [0.3784063098306413, 0.01018756575849844], [0.43806374889930155, 0.2268325586117821], [0.7411632641820634, 0.35513151640087337], [0.3884706603234591, 0.34043302784114093], [0.08674110453583683, 0.4491174987265194], [0.9794883193315694, 0.11207520940235804], [0.7496156619797683, 0.23845386610980834], [0.4423888847621813, 0.17212722421686055], [0.2276570035864689, 0.6515924491551327], [0.836939257954547, 0.0499933914625984]] # Length=8.587

'''
N2 = N**0.5
for i in range(int(N2)):
	for j in range(int(N2)):
		c = [i/N2, j/N2]
		cities.append(c)
'''

print(cities)

def dist (x, y):
	return ( (x[0]-y[0])**2 + (x[1]-y[1])**2 ) ** 0.5

def globaldist (chromosome):
	acum = 0.0
	for i in range(len(chromosome)):
		acum += dist(cities[chromosome[i-1]],cities[chromosome[i]]) # -1 is the last element
	return acum


# how to use genetics library
# first, define a fenotype function: given a chromosome returns an individual

# init graphics
plt.ion()
fig = plt.figure()
axes = fig.add_subplot(111)
xlim = axes.set_xlim(0.0,1.0)
ylim = axes.set_ylim(0.0,1.0)
x = []
y = []
l1, = axes.plot(x, y,'g')
l2, = axes.plot(x, y,'ro')

def orderedcities (chromosome):
	res = []
	x = []
	y = []
	for g in chromosome:
		res.append(cities[g])
		x.append(cities[g][0])
		y.append(cities[g][1])
	x.append(x[0])
	y.append(y[0])
	l1.set_data(x, y)
	l2.set_data(x, y)
	return res

def phenotype (chromosome):
	orderedcities(chromosome)
	s = 'Length=%5.3f' % globaldist(chromosome)
	plt.title(s)
	return s

# second, define a fitness function: given an chromosome, returns a number indicating the goodness of that chromosome

def fitness (chromosome): # priorize ordered genes
	score = globaldist(chromosome)
	return (1.0+N*0.1)/(1.0+score) # asume un promedio de distancia de 0.1 entre dos ciudades adyacentes en el óptimo para que en esas condiciones el optimo sea aprox. 1.0


# third: if desired, force parameters in UI
# valid parameters: alphabet, type, chromsize, elitism, norm, pmut, pemp, popsize

parameters = { 'alphabet':list(range(N)), 'type':'permutation', 'target':1.3 }

# cuestiones:
# ¿Encuentra siempre la mejor solución? ¿Por qué?
# ¿Crees que se puede estar seguro de haber encontrado la solución óptima?
# ¿Es útil repetir la optimización varias veces? ¿Por qué?
# Calcula el número de soluciones posibles y el tiempo que tardaría una máquina si generar cada una y comprobar su longitud le llevara un microsegundo
# número de permutaciones = n!
# teniendo en cuenta que cada camino puede hacerse en dos direcciones el total sería n! / 2
